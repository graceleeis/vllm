// !!! This is a file automatically generated by hipify!!!
#include <hip/hip_runtime.h>
#include <ATen/ATen.h>

namespace vllm {

template<typename scalar_t>
__global__ void rotary_embedding_neox_kernel(
  const int64_t* __restrict__ positions,        // [num_tokens]
  scalar_t* __restrict__ query,                 // [num_tokens, num_heads, head_size]
  scalar_t* __restrict__ key,                   // [num_tokens, num_kv_heads, head_size]
  const scalar_t* __restrict__ cos_sin_cache,   // [max_position, 2, rot_dim // 2]
  const int rot_dim,
  const int query_stride,
  const int key_stride,
  const int num_heads,
  const int num_kv_heads,
  const int head_size) {
  // Each thread block is responsible for one token.
  const int token_idx = hipBlockIdx_x;
  int64_t pos = positions[token_idx];
  const scalar_t* cache_ptr = cos_sin_cache + pos * rot_dim;

  const int embed_dim = rot_dim / 2;
  const int nq = num_heads * embed_dim;
    // Compute the query and key vectors for each head.
  for (int h = 0; h < num_heads; ++h) {
    for (int e = 0; e < embed_dim; ++e) {
      const int q_idx = h * embed_dim + e;
      const int k_idx = h * num_kv_heads * embed_dim + e;

      const scalar_t sin_w = cache_ptr[e];
      const scalar_t cos_w = cache_ptr[embed_dim + e];

      scalar_t q = query[token_idx * query_stride + q_idx];
      scalar_t k = key[token_idx * key_stride + k_idx];

      query[token_idx * query_stride + q_idx] = q * cos_w + k * sin_w;
      key[token_idx * key_stride + k_idx] = k * cos_w - q * sin_w;
    }
  }
}

template<typename scalar_t>
void rotary_embedding_neox(
  const at::Tensor& positions,
  at::Tensor& query,
  at::Tensor& key,
  const at::Tensor& cos_sin_cache,
  const int rot_dim,
  const int num_heads,
  const int num_kv_heads,
  const int head_size) {
  const int num_tokens = positions.size(0);
  const int query_stride = num_heads * head_size;
  const int key_stride = num_kv_heads * num_heads * head_size;

  const dim3 grid(num_tokens);
  const dim3 block(1);

 hipLaunchKernelGGL(( rotary_embedding_neox_kernel<scalar_t>), dim3(grid), dim3(block), 0, 0, 
    positions.data_ptr<int64_t>(),
    query.data_ptr<scalar_t>(),
    key.data_ptr<scalar_t>(),
    cos_sin_cache.data_ptr<scalar_t>(),
    rot_dim,
    query_stride,
    key_stride,
    num_heads,
    num_kv_heads,
    head_size);
}

} // namespace vllm